---
/** Malla.astro (columnas dinámicas + scroll X + diagonal + fade al desbloquear) */
import defaultMallaData from '../data/INF.json';
---

<!-- Inyectamos la malla por defecto para uso en el cliente -->
<script type="application/json" id="default-malla-json">
  {JSON.stringify(defaultMallaData)}
</script>

<!-- Columna centro: Título (se centra en md+) -->
<div class="mt-4 text-center">
  <p class="text-2xl md:text-3xl font-semibold text-gray-700">Malla Interactiva</p>
</div>

<!-- Header de progreso -->
<div id="progressHeader" class="max-w-[340px] md:max-w-[1440px] w-full mx-auto text-center mb-4 mt-8">
  <p class="text-sm text-gray-600">
    <span id="progressCount" class="font-semibold">0</span>/<span id="progressTotal">0</span> ramos aprobados
  </p>
</div>

<!-- Contenedor con scroll horizontal en móvil, ancho contenido centrado en xl -->
<div class="w-full mx-auto xl:max-w-[1440px]">
  <div id="scrollArea" class="overflow-x-auto xl:overflow-visible -mx-4 px-4 pb-2">
    <div id="mallaContainer" class="py-2"></div>
  </div>
</div>

<!-- Leyenda -->
<div id="leyenda" class="mt-8 px-6 py-5 bg-gray-50 rounded-lg w-full mx-auto max-w-[340px] md:max-w-[1440px]">
  <h4 class="text-lg font-bold mb-4 text-center">Leyenda</h4>
  <div class="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
    <div class="flex items-center gap-2"><span class="inline-block w-4 h-4 rounded bg-gray-300"></span>Bloqueado</div>
    <div class="flex items-center gap-2"><span class="inline-block w-4 h-4 rounded bg-gray-500"></span>Disponible</div>
    <div class="flex items-center gap-2"><span class="inline-block w-4 h-4 rounded bg-gray-900"></span>Disponible (hover)</div>
    <div class="flex items-center gap-2"><span class="inline-block w-4 h-4 rounded bg-gray-900 relative">
      <span class="absolute left-[-25%] top-1/2 w-[150%] h-[2px] rotate-[-20deg] bg-white/90"></span></span>
      Aprobado (línea diagonal)
    </div>
  </div>
</div>

<!-- Estilos -->
<style is:inline>
  :root {
    /* Línea diagonal en ramos aprobados */
    --strike-angle: -30deg;
    --strike-width: 8px;
    --strike-color: 128,128,128;
    --strike-opacity: 0.9;
    --strike-offset: -25%;
    --strike-length: 150%;

    /* Color del bloqueado (gris-300 Tailwind) para el pre-pintado */
    --locked-bg: #d1d5db;

    /* Ancho base de columna (puedes ajustarlo globalmente si quieres) */
    --col-w: 120px;
  }

  .ramo {
    position: relative;
    overflow: hidden;
    /* transición SUAVE solo de color (y filtro por si quieres algo de brillo) */
    transition: background-color .6s ease, filter .6s ease;
  }
  .ramo.aprobado::after {
    content: "";
    position: absolute;
    top: 50%;
    left: var(--strike-offset);
    width: var(--strike-length);
    height: var(--strike-width);
    transform: rotate(var(--strike-angle));
    background: rgba(var(--strike-color), var(--strike-opacity));
    pointer-events: none;
  }
  .ramo, .ramo * { text-rendering: optimizeLegibility; }

  /* Scroll cómodo en iOS/Android */
  #scrollArea { -webkit-overflow-scrolling: touch; scroll-behavior: smooth; }

  /* ❗️IMPORTANTE: NO forzamos 11 columnas aquí.
     El número de columnas se setea inline desde JS con style="grid-template-columns: repeat(n, var(--col-w))" */

  /* Scroll snap por columna (opcional) */
  #scrollArea { scroll-snap-type: x mandatory; }
  .scroll-snap-col { scroll-snap-align: start; }

  /* Estética scrollbar */
  #scrollArea::-webkit-scrollbar { height: 8px; }
  #scrollArea::-webkit-scrollbar-thumb { background: rgba(0,0,0,.15); border-radius: 8px; }
  #scrollArea::-webkit-scrollbar-track { background: transparent; }

  /* Respeto a reduced-motion */
  @media (prefers-reduced-motion: reduce) {
    .ramo { transition: none; }
  }
</style>

<script is:inline>
  // ====== Obtener malla por defecto del DOM ======
  function getDefaultMallaFromDOM() {
    const node = document.getElementById('default-malla-json');
    if (!node) return null;
    try { return JSON.parse(node.textContent || '{}'); } catch { return null; }
  }

  // ====== Utils de progreso ======
  const progressKey = (name) => `malla-progress-${name}`;
  function loadProgress(name) {
    try {
      const raw = localStorage.getItem(progressKey(name));
      return raw ? JSON.parse(raw) : { version: 1, name, approved: [] };
    } catch { return { version: 1, name, approved: [] }; }
  }
  function saveProgress(obj) {
    localStorage.setItem(progressKey(obj.name), JSON.stringify(obj));
  }
  function exportProgress(obj) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const stamp = new Date().toISOString().slice(0,10);
    a.href = url; a.download = `progreso-${obj.name}-${stamp}.json`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  // ====== Helpers de color ======
  function darken(hex, pct = 0.15) {
    try {
      const h = hex.replace('#','');
      const bigint = parseInt(h, 16);
      if (isNaN(bigint) || (h.length !== 6)) return hex;
      let r = (bigint >> 16) & 255;
      let g = (bigint >> 8) & 255;
      let b = bigint & 255;
      const f = 1 - Math.min(Math.max(pct, 0), 1);
      r = Math.round(r * f);
      g = Math.round(g * f);
      b = Math.round(b * f);
      return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
    } catch { return hex; }
  }

  // ====== Helpers de malla ======
  function flattenMalla(mallaData) {
    const items = [];
    const m = mallaData?.malla || {};
    Object.keys(m).forEach(semKey => {
      (m[semKey] || []).forEach(r => {
        items.push({
          nombre: r[0], sigla: r[1],
          creditosUSM: r[2], creditosSCT: r[3],
          categoria: r[4], prereqs: r[5] || [],
          indicador: r[6], semestreKey: semKey
        });
      });
    });
    return items;
  }
  function computeStateMap(allCourses, approvedSet) {
    const preMap = new Map(allCourses.map(c => [c.sigla, c.prereqs]));
    const state = new Map();
    allCourses.forEach(c => {
      if (approvedSet.has(c.sigla)) state.set(c.sigla, 'approved');
      else state.set(c.sigla, (preMap.get(c.sigla) || []).every(p => approvedSet.has(p)) ? 'available' : 'locked');
    });
    return state;
  }
  function groupBySemester(allCourses) {
    const groups = {};
    allCourses.forEach(c => {
      const n = c.semestreKey.replace('s', '');
      if (!groups[n]) groups[n] = [];
      groups[n].push(c);
    });
    Object.keys(groups).forEach(k => groups[k].sort((a,b) => a.nombre.localeCompare(b.nombre, 'es')));
    return groups;
  }
  function colorByCat(cat, categories) {
    return (categories && categories[cat]) ? categories[cat][0] : '#6B7280';
  }

  // ====== Render (con columnas dinámicas + fade al desbloquear) ======
  function render(mallaData, progress, prevStateMap) {
    const container = document.getElementById('mallaContainer');
    const all = flattenMalla(mallaData);
    const approved = new Set(progress.approved);
    const state = computeStateMap(all, approved);
    const grouped = groupBySemester(all);
    const categories = mallaData?.categories || {};

    // detectar ramos recién desbloqueados: locked -> available
    const justUnlocked = new Set();
    if (prevStateMap) {
      for (const c of all) {
        const before = prevStateMap.get(c.sigla);
        const now = state.get(c.sigla);
        if (before === 'locked' && now === 'available') justUnlocked.add(c.sigla);
      }
    }

    document.getElementById('progressTotal').textContent = String(all.length);
    document.getElementById('progressCount').textContent = String(approved.size);

    const semesters = Object.keys(grouped).sort((a,b) => Number(a) - Number(b));
    const cols = semesters.length; // ← dinámico (11, 10, …)

    const grid = `
      <div
        id="mallaGrid"
        class="grid gap-3 w-max xl:w-fit xl:mx-auto"
        style="grid-template-columns: repeat(${cols}, var(--col-w));"
      >
        ${semesters.map(n => `
          <div class="bg-white rounded-lg p-0.5 scroll-snap-col">
            <h3 class="text-center font-bold text-white text-sm mb-3 bg-gray-700 py-3 rounded h-12 flex items-center justify-center">
              SEMESTRE ${n}
            </h3>
            <div class="flex flex-col gap-1.5">
              ${(grouped[n] || []).map(c => {
                const s = state.get(c.sigla);
                const baseColor = colorByCat(c.categoria, categories);
                const isApproved = s === 'approved';
                const isLocked = s === 'locked';
                const canClick = s !== 'locked';

                // Fondo por estado:
                // - approved => color oscurecido
                // - locked   => gris
                // - available y justUnlocked => empieza como gris y luego transiciona a baseColor
                const approvedColor = darken(baseColor, 0.18);
                const targetColor = baseColor;
                const shouldPrePaintGray = !isLocked && !isApproved && justUnlocked.has(c.sigla);

                const inlineStyle = isLocked
                  ? ''
                  : isApproved
                    ? `background-color:${approvedColor}`
                    : shouldPrePaintGray
                      ? `background-color: var(--locked-bg);`
                      : `background-color:${targetColor}`;

                const dataTarget = shouldPrePaintGray ? `data-target-bg="${targetColor}"` : '';

                const classes =
                  `ramo text-xs 2xl:text-sm px-2 py-2 rounded font-medium text-center h-16 flex items-center justify-center gap-1 select-none
                  ${isLocked ? 'bg-gray-300 text-gray-600 cursor-not-allowed' : 'text-white hover:opacity-85 cursor-pointer'}
                  ${isApproved ? 'aprobado' : ''}
                  ${shouldPrePaintGray ? 'just-unlocked' : ''}`;

                return `
                  <button
                    class="${classes}"
                    style="${inlineStyle}"
                    ${dataTarget}
                    data-sigla="${c.sigla}"
                    data-state="${s}"
                    ${canClick ? '' : 'disabled'}
                    title="${c.sigla}${c.prereqs?.length ? ' | Prerrequisitos: ' + c.prereqs.join(', ') : ''}"
                  >
                    <span class="${isApproved ? 'opacity-95' : ''} block break-words whitespace-normal leading-tight text-[clamp(0.65rem,1.4vw,0.8rem)]">${c.nombre}</span>
                  </button>
                `;
              }).join('')}
            </div>
          </div>
        `).join('')}
      </div>
    `;
    container.innerHTML = grid;

    // Dispara el fade de los recién desbloqueados:
    // pasan de gris (--locked-bg) a su color de categoría (data-target-bg)
    const toTint = container.querySelectorAll('.ramo.just-unlocked[data-target-bg]');
    if (toTint.length) {
      requestAnimationFrame(() => {
        toTint.forEach(el => {
          const target = el.getAttribute('data-target-bg');
          if (target) el.style.backgroundColor = target;
        });
      });
    }

    // Toggle aprobado
    container.querySelectorAll('button[data-sigla]').forEach(btn => {
      btn.addEventListener('click', () => {
        const sigla = btn.getAttribute('data-sigla');
        const current = btn.getAttribute('data-state');
        if (current === 'locked') return;
        if (progress.approved.includes(sigla)) {
          progress.approved = progress.approved.filter(s => s !== sigla);
        } else {
          progress.approved.push(sigla);
        }
        saveProgress(progress);
        const prev = __prevState;
        __prevState = render(mallaData, progress, prev);
      });
    });

    // (Opcional) centrar hacia el primer desbloqueado en móvil
    if (justUnlocked.size > 0) {
      const first = [...justUnlocked][0];
      const el = container.querySelector(`button[data-sigla="${first}"]`);
      if (el) el.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
    }

    return state;
  }

  // ====== Boot ======
  let currentMalla = getDefaultMallaFromDOM() || { name: 'DEFAULT', malla: {}, categories: {} };
  let progress = loadProgress(currentMalla.name);
  let __prevState = null;
  __prevState = render(currentMalla, progress, __prevState);

  // ====== Cargar nueva malla desde botones del Header (por ID) ======
  document.getElementById('loadJsonBtn')?.addEventListener('click', () => {
    document.getElementById('jsonFileInput').click();
  });
  document.getElementById('jsonFileInput')?.addEventListener('change', (event) => {
    const file = event.target.files?.[0];
    if (!file) return;
    if (file.type !== 'application/json') {
      alert('Selecciona un archivo .json válido.');
      return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const newData = JSON.parse(e.target.result);
        currentMalla = newData;
        const newAll = new Set(flattenMalla(currentMalla).map(c => c.sigla));
        const old = loadProgress(currentMalla.name);
        const base = old && old.name === currentMalla.name ? old.approved : [];
        const filtered = base.filter(sig => newAll.has(sig));
        progress = { version: 1, name: currentMalla.name, approved: filtered };
        saveProgress(progress);
        const prev = __prevState;
        __prevState = render(currentMalla, progress, prev);
        alert('¡Malla cargada exitosamente!');
      } catch (err) {
        alert('Error al cargar el JSON: ' + (err?.message || err));
      }
    };
    reader.readAsText(file);
    event.target.value = '';
  });

  // ====== Importar/Exportar/Reset progreso ======
  document.getElementById('importProgressBtn')?.addEventListener('click', () => {
    document.getElementById('progressInput').click();
  });
  document.getElementById('progressInput')?.addEventListener('change', (event) => {
    const file = event.target.files?.[0];
    if (!file) return;
    if (file.type !== 'application/json') {
      alert('Selecciona un archivo .json válido.');
      return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const imported = JSON.parse(e.target.result);
        if (!imported || !Array.isArray(imported.approved) || !imported.name) {
          throw new Error('Formato inválido de progreso.');
        }
        const validSiglas = new Set(flattenMalla(currentMalla).map(c => c.sigla));
        const cleaned = imported.approved.filter(s => validSiglas.has(s));
        progress = { version: 1, name: currentMalla.name, approved: cleaned };
        saveProgress(progress);
        const prev = __prevState;
        __prevState = render(currentMalla, progress, prev);
        alert('¡Progreso importado!');
      } catch (err) {
        alert('Error al importar: ' + (err?.message || err));
      }
    };
    reader.readAsText(file);
    event.target.value = '';
  });

  document.getElementById('exportProgressBtn')?.addEventListener('click', () => exportProgress(progress));

  document.getElementById('resetBtn')?.addEventListener('click', () => {
    if (!confirm('¿Seguro que quieres reiniciar tu progreso?')) return;
    progress = { version: 1, name: currentMalla.name, approved: [] };
    saveProgress(progress);
    const prev = __prevState;
    __prevState = render(currentMalla, progress, prev);
  });

  // ====== Cargar malla por código (desde Header) ======
  async function fetchMallaByCode(code) {
    // Ajusta la base según tu despliegue (ej.: GitHub Pages con base)

    const url = `https://jqsilva.github.io/Malla-Interactiva/mallas/${code}.json`;
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`No se pudo cargar ${url}`);
    const data = await res.json();
    return data;
  }

  // Escucha el cambio de carrera desde el Header
  window.addEventListener('careerChange', async (ev) => {
    const code = ev?.detail?.code;
    if (!code) return;
    try {
      const newData = await fetchMallaByCode(code);
      currentMalla = newData;
      const newAll = new Set(flattenMalla(currentMalla).map(c => c.sigla));
      const old = loadProgress(currentMalla.name);
      const base = (old && old.name === currentMalla.name) ? old.approved : [];
      const filtered = base.filter(sig => newAll.has(sig));
      progress = { version: 1, name: currentMalla.name, approved: filtered };
      saveProgress(progress);
      const prev = __prevState;
      __prevState = render(currentMalla, progress, prev);
    } catch (err) {
      alert('Error al cambiar de carrera: ' + (err?.message || err));
    }
  });
</script>
